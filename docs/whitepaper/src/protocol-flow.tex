Let's summarize all of the above and describe the full flow of the Spectrum protocol.
Protocol is running by a set of manually selected opening consensus groups $\{V^k_1\}_{k=1}^K$\
for $K$ connected distributed systems $\{S_k\}_{k=1}^K$.
Each group consists of at least $M_k$ stakeholders interacting with each other and with the ideal\
functionalities $\mathcal{F}_{\text{Init}}$, ${\mathcal{F}}_{\text{VRF}}$, $\mathcal{H}$, ${\mathcal{F}}_{\text{LB}}$,\
$\mathcal{F}_{\text{AggSig}}$, ${\mathcal{F}}_{\text{KES}}$,\
$\mathcal{G}_{\text{ImpLClock}}$ and $\mathcal{G}_{\text{Ledger}}$ over a sequence of $L = E \cdot R$\
slots ${S=\{sl_1,\dots,sl_L\}}$ consisting of $E$ epochs with $R$ slots each.
Functionality ${\mathcal{F}}_{\text{AggSig}}$ implements the presented aggregated signature scheme logic.
Also, each protocol participant maintains at least one functionality unit  $\mathcal{F}^k_{\text{ConnSys}}$\
that allows him to interact with the connected $S_k$.

\subsubsection{Bootstrapping}\label{subsubsec:bootstrapping}

The system is bootstrapped in a trusted way.
All members of $\{V^k_1\}_{k=1}^K$ committees perform the following procedure:
\begin{enumerate}
    \item On-chain vaults are initialized with an aggregated public key $aPK^k_1$ of the initial committee.

    \item All committee $V^k_1$ members i.e. $\forall PK_i \in V^k_1$ must generate the tuple of verification keys\
    ${(v_i^{\text{vrf}}, v_i^{\text{kes}})}$, using the ideal functionalities ${\mathcal_{F}}_{\text{VRF}}$ and\
    ${\mathcal{F}}_{\text{KES}}$.

    \item Full set of the verification keys tuples\
    ${V_{init} = \{(v_i^{\text{vrf}}, v_i^{\text{kes}},)\}_{i=1}^M_k}$\
    with the initial stakes $\{s_i\}_{i=1}^M_k$ must be stored in the blockchain and\
    acknowledged by all members of the initial consensus group (meaning members of all $K$ committees and\
    a full set is $\{V_{init, k}\}_{k=1}^{K}$).

    \item Functionality ${\mathcal{F}}_{LB}$, parameterized with the confirmed $\{V_{init, k}\}_{k=1}^{K}$\
    is evaluated independently by every\
    participant to sample an initial random seed value $\eta \leftarrow \{0, 1\}^l$.

    \item Finally, all approved stakeholders should agree on the genesis block\
    ${B_0=\left(\{V_{init, k}, \text{stakes, k}\}_{k=1}^{K}, \eta\right)}$.
\end{enumerate}

\subsubsection{Chain Extension}\label{subsubsec:chain-extension}
Once the system is bootstrapped, the Spectrum protocol will run in a normal flow.

\begin{legal}

    \item Before the epoch $e_j$ begins all consensus participants receives new\
    epoch seed $\eta_n$ from the ${\mathcal{F}}_{\text{LB}}$ and calculates lotteries thresholds $T_n^{\text{lead}}$ and\
    $T_n^{\text{sync}}$.

    \item In the epochs first (synchronization) slot all $PK_i$ adjusts their local clocks according to previously\
    collected synchronization beacons set $B_i^{\text{sync}, n - 1}$.
    The corresponding $\textsf{shift}$ is calculated with the functionality $\mathcal{G}_{\text{ImpLClock}}$.

    \item During the epoch all online $V^k_n$ member collects existing chains from $L^+$ and verifying\
    that for every chain, every block, produced up to $U_f$ blocks before contains correct data about the\
    corresponding slot $sl'$ leader $PK'$.
    Leader $PK'$ must be also a member of the legitimate committee.
    All forks are resolved by the rules of the densest chain and the largest stake in the corresponding priority.

    \item During the epoch, for every slot $sl$ every committee $V^k_n$ member $PK_i$ separately evaluates\
    ${\mathcal{F}}_{VRF}$ with his own input ${x = \eta_n || sl || \textsf{LEAD}}$\ and compares the value
    ${y = \mathcal{H}(\pi^{\text{sl}*}||\textsf{LEAD})}$ with the associated threshold $T_n^{\text{lead}}$.
    If successful $PK_i$ is the slot $sl$ leader and he can initiate the notarization round in his local committee.

    In addition, during the first $R\//6$ slots of the epoch all $PK_i$ evaluates $\mathcal{F}_{\text{VRF}}$\
    functionality with input ${x = (\eta_n || sl_{\text{loc}, i})}$ to get a proof $\pi^{\text{sl}}$ and checks if\
    it has the right to release a synchronization beacon comparing the pseudo-random value\
    ${y_{\text{rand}^{\text{sync}}} = \mathcal{H}(\pi^{\text{sl}} || \textsf{SYNC})}$\
    with a corresponding threshold $T^{\text{sync}}_i$.
    If ${y_{\text{rand}^{\text{sync}}} < T^{\text{sync}}_i}$ then the participant broadcasts a beacon message\
    $b_{\text{sync, i}} = (v^{\text{vrf}}_i, sl_{\text{loc}, i}, \pi^{\text{sl}})$.

    \item All committee $V^k_n$ members observe events in their systems $S_k$ and in the $L+$ mempool.
    If $PK_i$ is a slot $sl$ leader, then he is able to propose a batch $b^*$ of events observed in $S_k$,\
    which should be notarized by other members of the $V^k_n$ with an aggregated signature\
    using ${\mathcal{F}}_{SIG}$ and then added to the local ledger $L_k$.

    \item Notarized batch $b^*$ can first be formed by any member of the $V^k_n$.
    The batch must be immediately sent to the leader who initiated its notarization and to the\
    members of other committees.
    After the leader receives enough batches he forms a block  $B^*$ consisting\
    of all external collected batches and batches from the local $L_k$ that have not yet been added to $L^+$.
    He includes his leadership proof $\pi^{\text{sl}}$, signs the block with ${\mathcal{F}}_{\text{KES}}$,\
    and broadcasts it to all committees.

    \item After the finality time $U_f$ is passed since $B^*$ settlement in the $L^+$,\
    all members of all committees that participated in the formation of the block $B^*$ can claim their rewards.

\end{legal}

\subsubsection{Epoch Transition}\label{subsubsec:epoch-transition}
\begin{legal}
    \item \textbf{Consensus Group Lottery}.
    At the end of the epoch ${e_{n-1} \gt 2}$ every verified $PK_i$ receives new epoch seed $\eta_n$\
    from the ${\mathcal{F}}_{LB}$.
    When every $PK_i$ evaluates ${\mathcal{F}}_{VRF}$ with the input, which includes new $\eta_n$\
    and passes the received proof $\pi^{\text{ep}}$.
    Function ${\mathcal{F}}_{L}$ is parameterized with the $S^k$ lottery parameters and uses the same\
    stake distribution which was in the last block used by ${\mathcal{F}}_{LB}$ to calculate the threshold.
    Also, all participants must multiply all stakes by the corresponding multipliers, calculated from the activity\
    of participants in the previous epoch.
    If successful, i.e. ${\mathcal{F}}_{L}$ returns $1$, then $PK_i$ is a member of $V^k_n$.
    Functionality ${\mathcal{F}}_{LB}$ is parameterized with the history, including blocks with release times up to\
    ${-U_f}$ from the actual slot.
    Therefore, even in case of a rollback, the currently selected members of the consensus group remain legitimate.

    \item \textbf{Committee key aggregation}.
    Once the new committee is selected, nodes in the $V^k_n$ aggregate their individual public keys $PK_i$ into
    a joint one $aPK^k_n$, which is needed to sign the batch applying transactions with the external events:\
    inbound value transfers, outbound value transfers, boxes eliminations.

    \item \textbf{Committee transition}.
    Nodes in the $V^k_{n - 1}$ publish cross-chain message ${m^k_n : (aPK^k_n, \sigma^k_{n-1})}$, where $\sigma^k_{n-1}$ is\
    an aggregated signature such that ${verify: (\sigma^k_{n-1}, aPK^k_{n-1}, m^k_n) = 1}$.
    Finally, vaults are updated such that ${vault^k\{(e_{n-1}, aPK^k_{n-1})\} \coloneqq(e_n, aPK^k_n)}$.
\end{legal}

\textbf{Registration\/\De-registration}.
Any Spectrum stakeholder can register to become a committee member of his local system $S_k$.
To get a chance to be included in the set of validators $V^k_n$ of the epoch $e_n$\
participant $PK_i$ should register in the lottery during the epoch $e_{n-2}$ by publishing his verification tuple\
${(v_i^{vrf}, v_i^{kes})}$ into the $L^+$.
Once number of slots corresponding to the Spectrum's finality time $U_f$ has elapsed,\
the participant is considered as verified.

In this way, the Spectrum protocol reaches consensus and implements the cross-chain interoperability.
The solution is fairly decentralized, fast and scalable, thus, it can be used in\
a large number of applications and scenarios.