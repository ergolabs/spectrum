Spectrum network is complex since it works with multiple connected blockchains.
In order to accurately describe and verify all the necessary properties of the Spectrum ledger, we should agree on the\
semantics and introduce data types that satisfy some validity conditions which we will describe in this section.


todo

\subsubsection{Forks}\label{subsec:resolving-forks}

Protocol flow implies that there can be a several local leaders in every connected $L_k$ committee,\
which leads to forks.
This type of fork is a normal part of the protocol lifecycle, however, total possible number of the normal forks in\
our protocol is much larger than in other blockchains, since any of the local leaders can append their blocks to $L^+$.
The chance of occurring a malicious forks produced by adversary is minimized due to the lottery\
and the incentive mechanism design.
In addition, the task for an adversary becomes more difficult by virtue of the interaction between the protocol\
participants during the syncing shards process.

For the above reasons, the main rules for resolving forks are simple and are\
performed by members of all committees when validating a proposed blocks:
\begin{enumerate}
    \item \textit{Max valid}: choose the longest appropriate chain given a set of valid chains that are available\
    in the network.
    \item \textit{Max stake}: if the max valid rule doesn't resolve a slot battle, then the valid chain\
    chooses according to the real stake size of the battled leaders, the maximum stake is the winner.
    Stake distribution is picked from the actual blockchain snapshot for the current committee.
\end{enumerate}

However, a large number fo forks, still significantly affect properties, that maintain the integrity of the $L^+$:
\begin{enumerate}
    \item \textit{Latency}: the number of elapsed slots required for a transaction to appear in a block on the $L^+$.
    \item \textit{Finality}: the number of elapsed slots required for a transaction to become settled and immutable.
\end{enumerate}
The latency of the protocol is good enough due to the short duration of the slots, while the finality,\
as a result of the functional features of our protocol, depends on the connected $c_k$ integrity properties.

Most ledgers do not guarantee instant finality of transaction, that means that any (or all) transactions may not\
be applied to the corresponding $c_k$ ledgers in the end.
Different blockchains has different finality parameters, and finality time of $K_f$ should be longer\
than all of them.
Thus, the $K_f$ should be set with a margin and, therefore, using the number of slots $\Delta sl$ that have\
passed in the Spectrum network, developers should be able to receive information about the number of blocks that\
have passed in all connected blockchain during this period of time.
The duration of the block in each $c_k$ is different, but the average values are preserved for a certain period of\
time ${\Delta T >> d_s}$, where $d_s$ is the duration of Spectrum's slot.
Thus, after each $\Delta T$ time interval, Spectrum network will update the set of constants:\
${(\{d_{k}\}_{k=0}^{K},\{r_k\}_{k=0}^{K})}$, where $d_k$ is a block duration in the $L_k$, $r_k$ is the default\
reliable number of confirmations in the $c_k$ and $K$ is the total number of the connected $c_k$.

Using the data above, each Spectrum's $\Delta sl$ can be associated with the delta of blocks that have passed in\
any connected blockchain: ${\{\lfloor \Delta sl \cdot d_s \mathbin{/} d_k)\rfloor\}_{k=0}^{K}}$.
When forming transaction, developers can specify a reliability factor $C$.
This factor will be compared with the ratio of the number of blocks passed on the associated $L_k$ blockchain to\
the default reliable number of confirmations $r_k$ of this network:
\begin{align*}
    \theta(k-c_k^{id})\cdot \left\{\frac{1}{r_k} \cdot \left\lfloor \Delta sl \cdot
    \frac{d_s}{d_k}\right\rfloor\right\}_{k=0}^{K} >= C,
\end{align*}
where $\theta(x)$ is an indicator function which is 1 at $x = 0$, otherwise 0.

\subsubsection{Handling Rollbacks}\label{subsec:rollbacks}
todo

\subsubsection{State Transition System}
todo