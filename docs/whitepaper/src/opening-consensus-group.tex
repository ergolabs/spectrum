Spectrum is an open-membership protocol, so PBFTNetwork's assumption on a closed consensus group is not valid.
Sybil attacks can break any protocol with security thresholds and an appropriate dynamic selection of\
the consensus group becomes crucial for preserving network's liveness and safety.
Consensus group members selection should be performed in a random and trusted way to ensure that a sufficient fraction\
(at most $f$ out of ${3 f + 1}$) of the selected members are honest and of course\
the selection procedure must be independent of any internal or external advisers.

Similar selection mechanics are required in most blockchain protocols.
Bitcoin~\cite{nakamoto2009bitcoin} and many its successors are using Proof-of-Work (PoW) consensus,\
which, in essence, is a robust mechanism that facilitates randomized selection of a leader who is\
eligible to produce a new block.
Later, PoW approach was adapted into a Proof-of-Membership mechanism ~\cite{kokoriskogias2016enhancing}\.
This mechanism allows once in a while to select a new consensus group\
which then executes the PBFT consensus protocol.

A primary consideration regarding PoW-based consensus mechanisms is\
the amount of energy required to operate such systems.
A natural alternative to PoW is a mechanism based on the concept of Proof-of-Stake (PoS)~\cite{King2012PPCoinPC}.
Rather than investing computational resources in order to participate in the leader selection process,\
participants of a PoS system instead run a process that randomly selects one of them proportionally to the stake.
Pure PoS mechanism to solve the PBFT problem was firstly used in~\cite{cryptoeprint:2017/454} to select both consensus\
group members and PBFT rounds leaders and to introduce randomness into this process,\
a verifiable Random Function (VRF) has been applied.

\subsubsection{Verifiable Random Function}

A Verifiable Random Function (VRF)~\cite{Micali1999} is a reliable way to introduce randomness into a protocol.
By definition, a function $\mathcal{F}$ can be attributed to the VRF family if the following methods are defined\
for the $\mathcal{F}$:
\begin{itemize}
    \item Gen: ${Gen(1^k) \rightarrow (PK, SK)}$, where $PK$ is the public key and $SK$ is the secret key;
    \item Prove: ${Prove(x, SK) \rightarrow \pi}$, where $x$ is an input and $\pi \vcentcolon= \Pi(x, SK)$ is\
    the proof, associated with $x$ and mixed with some random value $y$, sampled from $\{0,1\}^{l_{VRF}}$.
    \item Verify: ${Verify(x, \pi, PK) \rightarrow 0 | 1}$, where the output is $1$ if\
    and only if ${\pi \equiv \Pi(x, SK)}$.
\end{itemize}

The most secure nowadays are an Elliptic Curve Verifiable Random Functions (ECVRFs).
Basically, ECVRF is a cryptographic-based VRF that satisfies the trusted uniqueness, trusted collision resistance,\
and full pseudorandomness properties ~\cite{cryptoeprint:2014/905}.
The security of ECVRF follows from the decisional Diffie-Hellman assumption in the random oracle model, thus\
ECVRF is a good source of randomness for a blockchain protocol.
Using ECVRF is also cheap and fast, since single ECVRF evaluation is approximately 100 microseconds on\
x86-64 for a specific curves used in hash functions.
Moreover, there is a great UC-extension for batch verification proposed by ~\cite{cryptoeprint:2022/1045}\
which make it even faster.

\subsubsection{Lottery}
Our lottery mechanism is based on ECVRF as a source of randomness and is generally inspired\
by~\cite{cryptoeprint:2017/573}.
The lottery is designed to achieve two main purposes: \emph{select a consensus group dynamically},
\emph{select a slot leader}.

\textbf{Lottery Function}.
The main selection logic is implemented in the lottery function.
The lottery function ${\mathcal{F}}_{L}$ compares a random number $y$ derived from the generated VRF random\
proof $\pi$ with publicly known threshold value $T$.
It evaluates to $1$ if and only if ${y < T}$, i.e.\
${\mathcal{F}}_{L}(state, f, \pi) \rightarrow 0|1$ where $state$ is a blockchain state snapshot.

The threshold value is calculated according to the formula ${T = 2^{l_{VRF}}\cdot \phi(\alpha, f)}$ where\
${\alpha=s/\\\sum_{l=0}^{l=M} s_l}$ is a relative stake.
Consequently, the probability of winning is calculated as ${p(\alpha, f) = 1-(1-f)^{\alpha}}$\
Winning probability depends on the participants' relative stake and is adjusted by the free parameter $f$.
This is where the PoS concept comes into play: the bigger the stake, the higher the chance of winning the lottery.

\textbf{Consensus Group Lottery}.
The Spectrum protocol initially is running by the manually selected opening consensus group $\{PK_i\}_{i=1}^M$\
of the predefined size $M$.
Stakeholders interact with each other and with locally installed ideal functionalities ${\mathcal{F}}_{LB}$,\
${\mathcal{F}}_{VRF}, {\mathcal{F}}_{L}$ over a sequence of $L = E \cdot R$ slots\
${S=\{sl_1,...,sl_L\}}$ consisting of $E$ epochs with $R$ slots each.
Let's clarify what the mentioned above pre-defined primitives are needed for:
\begin{enumerate}
    \item \emph{Ideal Leaky Beacon} ${\mathcal{F}}_{LB}$: is used to sample an epoch random seed from the\
    blockchain.
    \item \emph{Ideal Verifiable Random Function} ${\mathcal{F}}_{VRF}$: is used as a source of randomness.
    \item \emph{Lottery Function} ${\mathcal{F}}_{L}$: checks if the protocol participant is a lottery winner\
    (by lottery, we mean either the \emph{consensus group lottery} or the \emph{leader lottery} giving\
    the ability to start a batch notarization round, the lottery function in both cases remains the same,\
    only the arguments matter).
\end{enumerate}
More extended formal definition of ${\mathcal{F}}_{LB}$ and ${\mathcal{F}}_{VRF}$ can be found in the original\
Ouroboros Praos paper ~\cite{cryptoeprint:2017/573}.

Each new epoch ${e_j \gt 1}$ has a new consensus group and any protocol participant\
can try to become a member if he is verified.
Participant is verified if his verification key tuple is published and stored in the blockchain for a\
reliable period of time equals to $U_f$ slots.

At the end of the epoch ${e_j \gt 1}$ every verified $PK_i$ requests a\
new epoch seed $\eta_j$ from the ${\mathcal{F}}_{LB}$.
When every $PK_i$ evaluates ${\mathcal{F}}_{VRF}$ and passes the received proof $\pi$ to the ${\mathcal_{F}}_{L}$ to\
reveal the result of the consensus group lottery.
To calculate an appropriate threshold ${T_i^j}$, ${\mathcal{F}}_{L}$ should be parametrized with the same\
stake distribution which was in the last block used by ${\mathcal{F}}_{LB}$ to sample the new $\eta_j$.
Argument of the winning probability function $p$ is ${f = M /\/ N}$, where $M$ is a number of new consensus group\
members to select and $N$ is the total number of the verified stakeholders.

For security purposes, a lower bound number of committee members $M$ is required.
If the number of verified participants is less than ${M_{\min}=256}$, then the consensus group lottery is not held.
The maximum consensus group size is ${M_{\max}=1024}$, this limit arises due to the complexity of communication.

\textbf{Leader Lottery}.
Once a new consensus group is determined, the lottery process does not stop, but this time\
the leader of the group should be determined.

During an epoch, for each slot ${sl_l \in S}$, each member of the consensus group $PK_i$ separately evaluates\
${\mathcal{F}}_{VRF}$ with his own input ${x = \eta_j || sl_l || \emph{nonce}}$.
In response, he receives the associated random proof $\pi$.
If ${\mathcal{F}}_{L}(state, f, \pi) \rightarrow 1$ then $PK_i$ is a slot leader and he can propose a batch\
which should be notarized by at least two-thirds of committee members.

The parameter $f$ that regulates the probability of winning is different from the one used in the consensus\
group lottery.
Here, it is the pre-defined value determines how many slots will have at least one selected leader,\
it is called an active slots coefficient.

The lottery mechanism described in this subsection is fast, secure, and adaptive, since the pre-defined parameters\
can be changed via the voting process.
The same primitives are used to achieve different goals, namely, select a consensus group dynamically\
and select a slot leader.

Regarding the security it is important to note, that participants use their public VRF-keys for\
VRF functionality evaluation in the consensus group lottery and secret VRF-keys in the leader lottery.
This way, slot leaders don't become publicly known in advance.
An attacker can't see who is a slot leader until he initializes batch notarization, thus an attacker can't know\
who specifically to attack in order to control a certain slot.
Opening consensus group members on the over hand should be known ahead of time for the synchronization.
There are hundreds of consensus members in every epoch, so denial of service attacks are difficult to succeed.
Grinding attacks are limited because an adversary can't arbitrarily control $\eta_j$ values,
all he can try to do is to make as many forks as possible to estimate the most advantageous, but according to the\
analysis~\cite{cryptoeprint:2017/573} this advantage doesn't change the security properties of the entire protocol.

