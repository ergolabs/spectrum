Spectrum is an open-membership protocol, so PBFTNetwork's assumption on a closed consensus group is not valid.
Sybil attacks can break any protocol with security thresholds and an appropriate dynamic selection of\
the consensus group becomes crucial for preserving network's liveness and safety.
Election of consensus group members should be performed in a random and trustless way to ensure that a sufficient fraction\
(at most $f$ out of ${3 f + 1}$) of members are honest.

Similar selection mechanics is required in most blockchain protocols.
Bitcoin~\cite{nakamoto2009bitcoin} and many its successors are using Proof-of-Work (PoW) consensus,\
which, in essence, is a robust mechanism that facilitates randomized selection of a leader who is\
eligible to produce a new block.
Later, PoW approach was adapted into a Proof-of-Membership mechanism~\cite{kokoriskogias2016enhancing}.\
This mechanism allows once in a while to select a new consensus group\
which then executes the PBFT consensus protocol.

A primary consideration regarding PoW-based consensus mechanisms is\
the amount of energy required to operate such systems.
A natural alternative to PoW is a mechanism based on the concept of Proof-of-Stake (PoS)~\cite{King2012PPCoinPC}.
Rather than investing computational resources in order to participate in the leader selection process,\
participants of a PoS system instead run a process that randomly selects one of them proportionally to the stake.
Pure PoS mechanism to solve the PBFT problem was firstly used in~\cite{cryptoeprint:2017/454} to select both consensus\
group members and PBFT rounds leaders and to introduce randomness into this process,\
a verifiable Random Function (VRF) has been applied.

\subsubsection{Verifiable Random Function}

A Verifiable Random Function (VRF)~\cite{Micali1999} is a reliable way to introduce randomness into a protocol.
By definition, a function $\mathcal{F}$ can be attributed to the VRF family if the following methods are defined\
for the $\mathcal{F}$:
\begin{itemize}
    \item Gen: ${Gen(1^k) \rightarrow (PK, SK)}$, where $PK$ is the public key and $SK$ is the secret key.
    \item Prove: ${Eval(x, SK) \rightarrow \pi}$, where $x$ is an input and $\pi \vcentcolon= \Pi(x, SK)$ is\
    the proof, associated with $x$ and mixed with some random value $y$, sampled from $\{0,1\}^{l_{VRF}}$.
    \item Verify: ${Verify(x, \pi, PK) \rightarrow 0 | 1}$, where the output is $1$ if\
    and only if ${\pi \equiv \Pi(x, SK)}$.
\end{itemize}

The most secure implementations of VRF nowadays are Elliptic Curve Verifiable Random Functions (ECVRFs).
Basically, ECVRF is a cryptographic-based VRF that satisfies the uniqueness, collision resistance,\
and full pseudorandomness properties~\cite{cryptoeprint:2014/905}.
The security of ECVRF follows from the decisional Diffie-Hellman assumption in the random oracle model, thus\
ECVRF is a good source of randomness for a blockchain protocol.
Using ECVRF is also cheap and fast, since single ECVRF evaluation is approximately 100 microseconds on\
x86-64 for a specific curves used in hash functions.
Moreover, there is a great UC-extension for batch verification proposed by~\cite{cryptoeprint:2022/1045}\
which make it even faster by reducing the number of evaluations.

\subsubsection{Lottery}
Our lottery mechanism is based on ECVRF as a source of randomness and is generally inspired\
by Ouroboros Praos~\cite{cryptoeprint:2017/573} and Algorand~\cite{cryptoeprint:2017/454}.
The lottery mechanism in general allows the protocol assign a specific \emph{role} to a participant,\
while the validity of the participant's role can be verified using only publicly available data.

The main assigning logic is as follows:
\begin{legal}
    \item Participant calculates a certain threshold value $T$ according to predefined rules and\
    using only publicly available data for the calculation.
    \item Participant evaluates VRF function and calculates a random number $y$ using the VRF's proof $\pi$.
    \item If ${y < T}$ then the participant is considered valid for the respective role.
\end{legal}

To be more precise, let's clarify that in our setting a threshold value $T$ is calculated according\
to the formula ${T = 2^{l_{\text{VRF}}}\cdot \phi(\alpha, f)}$ where\
${\alpha=s/\\\sum_{l=0}^{M} s_l}$ is a relative stake.
Consequently, the probability of winning is calculated as ${p(\alpha, f) = 1-(1-f)^{\alpha}}$.
Thus, the winning probability depends on the participant's relative stake and is adjusted by the free parameter $f$.
This is where the PoS concept comes into play: the bigger the stake, the higher the chance of winning the lottery.

The lottery mechanism is fast, secure, and adaptive, since the involved pre-defined parameters\
can be changed via the voting process.
Moreover, the same primitives can be used to achieve different goals and we will utilize the lottery mechanism\
in several aspects of our protocol.

\textbf{Consensus Group Lottery}.
In the current section, we are considering a lottery mechanism application for \emph{dynamic consensus group selection}.
The Spectrum protocol initially is running by the manually selected opening consensus group $\{PK_i\}_{i=1}^M$\
of the predefined size $M$.
Stakeholders interact with each other and with locally installed ideal functionalities\
$\mathcal{F}_{\text{VRF}}$ and $\mathcal{F}_{\text{LB}}$ over a sequence of $L = E \cdot R$ slots\
${S=\{sl_1,\dots,sl_L\}}$ consisting of $E$ epochs with $R$ slots each.
Let's clarify what the mentioned above pre-defined primitives are needed for:
\begin{enumerate}
    \item \emph{Ideal Leaky Beacon} $\mathcal{F}_{\text{LB}}v$: is used to sample an epoch random seed from the\
    blockchain.
    \item \emph{Ideal Verifiable Random Function} $\mathcal{F}_{\text{VRF}}$: is used as a source of local randomness.
\end{enumerate}
More extended formal definition of ${\mathcal{F}}_{\text{LB}}$ and ${\mathcal{F}}_{\text{VRF}}$ can be found in the original\
Ouroboros Praos paper ~\cite{cryptoeprint:2017/573}.

Consensus group is constantly rotated each epoch ${e_j \gt 1}$.
Any verified protocol participant can try to become a temporal member of consensus group.
Participant is verified if his verification key tuple is published and stored in the blockchain for a\
reliable period of time equals to $U_f$ slots.
The consensus group lottery flow is as follows:
\begin{enumerate}
    \item At the end of the epoch ${e_j \gt 1}$ every verified $PK_i$ requests a\
    new epoch seed $\eta_j$ from the ${\mathcal{F}}_{\text{LB}}$.
    \item New consensus lottery threshold $T_i^{\text{cons}}$ is calculated using stake distribution\
    (to get a relative stake) from the last block used by ${\mathcal{F}}_{\text{LB}}$ to sample the new $\eta_j$.
    Free parameter $f$ of the associated function $\phi$ is ${f = M /\/ N}$, where $M$ is a pre-defined\
    number of new consensus group members to select and $N$ is the total number of the verified stakeholders.
    \item When every $PK_i$ evaluates ${\mathcal{F}}_{\text{VRF}}$ with input $x = \eta_j || e_j $ and calculates\
    the associated random number $y$ from the received proof $\pi^{\text{e}}$, i.e.\
    ${y = \mathcal{H}(\pi^{\text{e}*}||\textsf{CONS})}$, where $\pi^{\text{e}*}$ is a random number, extracted\
    from the proof and $\textsf{CONS}$ is a pre-defined constant.
    \item To reveal the result of the consensus group lottery $PK_i$ compares $y$ with $T_i^{\text{cons}}$ and\
    if ${y < T_i^{\text{cons}}}$ then the participant is a legal member of new consensus group\
    which will be active in the epoch $e_{j+2}$.
    \item Finally, to declare his right to participate in the new consensus group, the participant\
    includes a message with the associated proofs $(e_{j+2}, v^{\text{vrf}}_i, \pi^{\text{e}})$ into the blockchain.
\end{enumerate}
Note, that consensus group members should be known ahead of time for the synchronization.
That is why the lottery for the $e_{j + 2}$ consensus group occurs at the end of epoch $e_j$.
A one-epoch pass is required for all evidence messages to become finally settled.
Public disclosure of the future consensus group doesn't give much advantage to an adversary\
since there are hundreds of consensus members in every epoch and denial of service attacks are difficult to succeed.
At the same time any grinding attacks are limited because an adversary can't arbitrarily control $\eta_j$ values.

The main task of the validators elected via the consensus group lottery is to observe and notarize events using a digital\
signature aggregation mechanism which we will introduce in the next sections.
