Spectrum is an open-membership protocol, thus, PBFTNetwork's assumption on a closed consensus group is nod valid.
Sybil attacks cat break any protocol with security thresholds and an appropriate dynamic selection of\
the opening consensus group become crucial for preserving network's liveness and safety.
Consensus group members selection should be performed in a random and trusted way to ensure that a sufficient fraction\
(at most $f$ out of ${3 f + 1}$) of the selected members are honest, of course,\
the selection procedure should be independent of any internal or external advisers.

Similar mechanics are required in most blockchains protocols.
Bitcoin~\cite{nakamoto2009bitcoin} and many of its successors are using Proof-of-Work (PoW) consensus,\
which is, in essence, is a robust mechanism that facilitates randomized selection of a leader that is\
eligible to produce a new block.
Later, PoW approach was adapted into a Proof-of-Membership mechanism ~\cite{kokoriskogias2016enhancing}\.
This mechanism allows, once in a while, to select a new consensus group,\
which then executes the PBFT consensus protocol.

A primary consideration regarding PoW-based consensus mechanisms is\
the amount of energy required to operate such systems.
A natural alternative to PoW is a mechanism, that relies on the concept of Proof-of-Stake (PoS)~\cite{King2012PPCoinPC}.
Rather than investing computational resources in order to participate in the leader selection process,\
participants of a PoS system instead run a process, that randomly selects one of them proportionally to the stake.
Pure PoS mechanism to solve the PBFT problem was firstly used in~\cite{cryptoeprint:2017/454} to select both consensus\
group members and PBFT rounds leaders and, to introduce randomness into this process,\
Verifiable Random Function (VRF) has been applied.

\subsubsection{Verifiable Random Function}

A Verifiable Random Function (VRF)~\cite{Micali1999} is a reliable way to introduce randomness in the protocol.
By definition the function $\mathcal{F}$ can be attributed to the VRF family if the following methods are defined\
for the $\mathcal{F}$:
\begin{enumerate}
    \item Gen: ${Gen(1^k) \rightarrow (pk, sk)}$, where $pk$ is the public key and $sk$ is the secret key;
    \item Prove: ${Prove(x, sk) \rightarrow \pi}$, where $x$ is an input and $\pi \vcentcolon= \Pi(x, sk)$ is\
    the proof, associated with $x$ and mixed with some random value $r$, sampled from $\{0,1\}^{l_{VRF}}$.
    \item Verify: ${Verify(x, \pi, pk) \rightarrow 0 | 1}$, where the output is $1$ if\
    and only if ${\pi \equiv \Pi(x, sk)}$.
\end{enumerate}

The most secure nowadays are an Elliptic Curve Verifiable Random Functions (ECVRF).
Basically, ECVRF is a cryptographic-based VRF that satisfies the trusted uniqueness, trusted collision resistance,\
and full pseudorandomness properties ~\cite{cryptoeprint:2014/905}.
The security of ECVRF follows from the decisional Diffie-Hellman (DDH) assumption in the random oracle model, thus\
it's a good source of randomness for the protocol.
Using ECVRF is also cheap and fast, single ECVRF evaluation is approximately 100 microseconds on\
x86-64 for a specific curves used in hash functions.
Moreover, there is also a great UC-extension for batch verification proposed by ~\cite{cryptoeprint:2022/1045}\
which make it even faster.

\subsubsection{Lottery mechanism}
Our lottery mechanism is based on the ECVRF as a source of randomness and is generally inspired\
by~\cite{cryptoeprint:2017/573}, it is generally designed to achieve two main purposes: consensus\
group reinitialization and leaders selection.

\textbf{Lottery Function}.
The lottery function ${\mathcal{F}}_{L}$ compares a random number $y$ derived from the generated VRF proof $\pi$ with\
publicly known threshold value $T$.
It evaluates to $1$ if and only if ${y < T}$, i.e.\
${\mathcal{F}}_{L}(state, f, \pi) \rightarrow 0|1$, where $state$ is a blockchain state snapshot.

The threshold value is calculated according to formula ${T = 2^{l_{VRF}}\cdot \phi(\alpha, f)}$, where\
${\alpha=s/\\\sum_{l=0}^{l=M} s_l}$ is a relative stake.
Consequently, the probability of winning is calculated as ${p(\alpha, f) = 1-(1-f)^{\alpha}}$\
and it depends on the participants' relative stake and is adjusted by the free parameter $f$.
This is where the PoS concept comes into play, the bigger the stake, the higher the chance of winning the lottery.

\textbf{Consensus Group Reinitialization}.
The Spectrum protocol initially is running by manually selected opening consensus group $\{PK_i\}_{i=0}^M$\
of the predefined size $M$.
Stakeholders interact with each other and with locally installed ideal functionalities ${\mathcal{F}}_{LB}$,\
${\mathcal{F}}_{VRF}, {\mathcal{F}}_{L}$ over a sequence of $L = E \cdot R$ slots\
${S=\{sl_1,...,sl_L\}}$ consisting of $E$ epochs with $R$ slots each.
Let's clarify what the mentioned above pre-defined primitives are needed for:
\begin{enumerate}
    \item \emph{Ideal Leaky Beacon} ${\mathcal{F}}_{LB}$: is used to sample an epoch random seed from the\
    blockchain.
    \item \emph{Ideal Verifiable Random Function} ${\mathcal{F}}_{VRF}$: is used as a source of randomness.
    \item \emph{Lottery Function} ${\mathcal{F}}_{L}$: checks if the protocol participant is a lottery winner\
    (by lottery, we mean either election to a consensus group or slot leadership, giving the ability to start\
    a batch notarization round, the lottery function in both cases remains the same, only the arguments matter).
\end{enumerate}
More extended formal definition of ${\mathcal{F}}_{LB}$ and ${\mathcal{F}}_{VRF}$ can be found in the original\
Ouroboros Praos paper ~\cite{cryptoeprint:2017/573}.

Each new epoch ${e_j \gt 1}$ has a new consensus group and any protocol participant\
can try to become a member if he is verified.
Participant is verified if his verification key tuple is published and stored in the blockchain for a\
reliable period of time equals to $K_f$ slots.

At the end of the epoch ${e_j \geq 1}$ every verified $PK_i$ requests a\
new epoch seed $\eta_j$ from the ${\mathcal{F}}_{LB}$.
When every $PK_i$ evaluates ${\mathcal{F}}_{VRF}$ and passes the received proof $\pi$ to the ${\mathcal_{F}}_{L}$ to\
reveal the result of the consensus group lottery.
To calculate an appropriate threshold ${T_i^j}^*$, ${\mathcal{F}}_{L}$ should be parametrized with the same\
stake distribution which was in the last block used by ${\mathcal{F}}_{LB}$ to sample a new $\eta_j$.
Argument of the winning probability function $p$ is ${f = M /\/ N}$, where $M$ is a number of new consensus group\
members to select and $N$ is the total number of the verified stakeholders.

For security purposes, a lower bound the number of committee members $M$ is required.
If the number of verified participants is less than ${M_{\min}=256}$, then the consensus group lottery is not held.
The maximum consensus group size is ${M_{\max}=1024}$, this limit arises due to the complexity of communication.

\textbf{Leader Selection}.
Once a new consensus group is determined, the lottery process does not stop, but this time the members\
must determine the leader of the group.

During the epoch, for every slot ${sl_l \in S}$ every consensus group member separately evaluates\
${\mathcal{F}}_{VRF}$ with his own input ${x = \eta_j || sl || \emph{nonce}}$ to a random proof  $\pi$
In response, he receives the associated proofs $\pi$ and $\rho_\pi$ respectively.
If ${\mathcal{F}}_{L}(state, f, \pi) \rightarrow 1$ then $PK_i$ is a slot leader and he can propose a batch\
which should be notarized by at least two-thirds of committee members.

The parameter $f$, that regulates the probability of winning is different from the one used in the consensus\
group lottery.
Here, it is the pre-defined value determines how many slots will have at least one selected leader,\
it is called an active slots coefficient.

The lottery mechanism described in this subsection is fast, secure, and adaptive, since the pre-defined parameters\
can be changed via the voting process.
The same primitives are used to achieve different goals, namely,\
dynamically reinitialize a consensus group and select slot leaders.

Regarding the security it is important to node, that participants use their public VRF-keys for\
VRF functionality evaluation in the consensus group lottery and secret VRF-keys in the leader lottery.
This way, we force slot leaders aren't publicly known ahead of time.
An attacker can't see who was a slot leader until he initializes batch notarization, thus an attacker can't know\
who specifically to attack in order to control a certain slot ahead of time.
Opening consensus group members on the over hand should be known ahead of time for the synchronization, there are\
hundreds of members at each epoch, thus denial of service attacks are difficult to succeed.
Grinding attacks are limited because an adversary can't arbitrarily control $\eta_j$ values.
All he can try to do is to make as many forks as possible to estimate the most advantageous, but according to the\
analysis this advantage doesn't change the security properties of the entire protocol.

